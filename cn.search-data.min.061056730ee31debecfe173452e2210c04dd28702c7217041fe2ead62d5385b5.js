'use strict';(function(){const indexCfg={encode:false,tokenize:function(str){return str.replace(/[\x00-\x7F]/g,'').split('');}};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/posts/picocli-tutorial/','title':"Picocli Tutorial",'content':" Picocli 是一个用Java编写的命令行参数解析库。\n常见参数含义: http://catb.org/~esr/writings/taoup/html/ch10s05.html#id2948149\n"});index.add({'id':1,'href':'/posts/plagiarism/','title':"Tools for Plagiarims Detection",'content':" moss  jplag  sim "});index.add({'id':2,'href':'/posts/ansi-code/','title':"ANSI Escape Code",'content':"The way that most programs interact with the Unix terminal is through ANSI escape codes. These are special codes that your program can print in order to give the terminal instructions. Various terminals support different subsets of these codes, and it\u0026rsquo;s difficult to find a \u0026ldquo;authoritative\u0026rdquo; list of what every code does. Wikipedia has a reasonable listing of them, as do many other sites.\n Build your own Command Line with ANSI escape codes "});index.add({'id':3,'href':'/posts/jline-tutorial/','title':"JLine Tutorial",'content':" JLine 是一个Java版的GNU ReadLine，通过它，我们可以很方便的实现一个多功能的命令行程序，支持历史记录，光标移动，自动补全，多行编辑，高亮等。\n基本用法 JLine最基本的类是LineReader，如下展示了一个最基本的使用方法:\npublic class Main { public static void main(String[] args) { LineReader reader = LineReaderBuilder.builder().build(); String prompt = \u0026#34;\u0026gt; \u0026#34;; while (true) { String line = null; try { line = reader.readLine(prompt); System.out.println(line); } catch (UserInterruptException e) { // Ignore  } catch (EndOfFileException e) { return; } } } } 这个命令行程序只支持左右移动光标，历史记录。通过配置LineReader我们可以让它支持更多功能，如自动补全，多行编辑等。\n 多行编辑 我们可以通过添加一个parser让reader支持多行编辑，如下:\n setEofOnUnclosedBracket配置允许\u0008输入大括号，圆括号，方括号时可以进行多行编辑。 setEofOnUnclosedQuote配置允许输入字符串时可以进行多行编辑。  DefaultParser parser = new DefaultParser(); parser.setEofOnUnclosedBracket(Bracket.CURLY, Bracket.ROUND, Bracket.SQUARE); parser.setEofOnUnclosedQuote(true); LineReader reader = LineReaderBuilder.builder().parser(parser).build(); 如果DefaultParser不满足你的要求，可以参考其实现自己重写一个，注意要继承Parser。\n配置多行编辑模式下的prompt(secondary prompt)\nLineReader reader = LineReaderBuilder.builder().variable(LineReader.SECONDARY_PROMPT_PATTERN, \u0026#34;%M%P \u0026gt; \u0026#34;) Virtual Terminal 配置terminal可以让\u0008程序面对不同平台时更加鲁棒。\nTerminal terminal = TerminalBuilder.builder().build(); LineReader reader = LineReaderBuilder.builder().terminal(terminal) 当需要输出内容时，使用:\nterminal.writer().println(line); Windows平台支持 Windows平台需要配置JNA, 首先到 Maven 下载jar文件（jar就可以了，source和javadoc可以不用），然后把下载下来的jar文件名改成jna.jar。\n在你编写的命令行程序的manifest里添加Class-Path，再把你编写的命令行程序打包成jar。\nClass-Path: jna.jar 运行时要求两个jar在同一个文件夹中。\n参考资料: https://stackoverflow.com/questions/16499084/java-exception-exception-in-thread-main-java-lang-noclassdeffounderror-net-s\n扩展内容 Option \u0026amp; Variable 通过LineReader.option和LineReader.variable可以对LineReader进行详细的配置。\n自动缩进 配置自动缩进：\nLineReader reader = LineReaderBuilder.builder().variable(LineReader.INDENTATION, 2) 仿Swift REPL 以下代码可以实现一个仿Swift REPL的命令行程序，支持：\n 光标移动，单行时为左右，多行时为上下左右。 多行编辑 快捷键复制粘贴 自动缩进 自动补全括号 历史记录 \u0026hellip;    GitHub "});index.add({'id':4,'href':'/posts/syntax-highlight-in-hugo/','title':"为Hugo添加Yan语言代码高亮支持",'content':"为了能让文档阅读起来更顺畅，更美观，我们通常会高亮文档中出现的代码。Hugo使用高亮器 chroma 来对代码进行分析实现代码高亮，但是chroma不支持我们自己定义的语言Yan。\n另一种高亮器是Pygments, 但是Hugo自0.6版本后就删除了使用pygments作为高亮器的选项。  为了能让Hugo支持高亮Yan语言，我们可以修改chroma或Pygments让它们支持高亮Yan语言，再重新编译Hugo，安装，但是，这种方法太麻烦了。因此，这里我们采用另一种方式进行workaround。\nWorkaround 1.扩展Pygments 我们首先扩展pygments，让其支持高亮Yan语言，详见 pgments-yanlexer 。\n扩展之后，我们可以使用下列指令获取高亮后的html的代码,以及对应的css代码:\n// 对power.yan进行高亮输出html pygmentize -f html -o power.html power.yan // 获取css代码 pygmentize -f html -a .highlight -S trac \u0026gt; highlight.css 2.复制HTML代码 我们知道markdown是支持直接渲染HTML代码，因此我们可以直接把转换后的HTML代码替换markdown里的代码块。\n3.复制CSS代码 为了让Hugo懂得如何渲染代码区域的HTML代码，我们需要把highlight.css里的所有内容复制到/assets/_custom.scss中。 再稍微调整一下字体，行距等:\n.highlight .yan{ border-radius: .15rem; font-size: .8em; line-height: 2em; font-family: \u0026#34;roboto mono\u0026#34;,monospace; } .highlight pre { background-color: #f8f9fa !important; } Hugo自己的代码块的trac风格背景色是纯白的，这样会不太好看，因此使用.highlight pre强制覆盖pre原来的背景色。  效果 HTML代码 \u0026lt;div class=\u0026#34;highlight\u0026#34;\u0026gt;\u0026lt;pre class=\u0026#39;yan\u0026#39;\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;k\u0026#34;\u0026gt;func\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;nf\u0026#34;\u0026gt;power\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;p\u0026#34;\u0026gt;(\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;n\u0026#34;\u0026gt;base\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;p\u0026#34;\u0026gt;:\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;kt\u0026#34;\u0026gt;int\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;p\u0026#34;\u0026gt;,\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;n\u0026#34;\u0026gt;e\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;p\u0026#34;\u0026gt;:\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;kt\u0026#34;\u0026gt;int\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;p\u0026#34;\u0026gt;)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;o\u0026#34;\u0026gt;-\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;kt\u0026#34;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;p\u0026#34;\u0026gt;{\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;k\u0026#34;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;n\u0026#34;\u0026gt;i\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;o\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;mf\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;p\u0026#34;\u0026gt;;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;k\u0026#34;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;n\u0026#34;\u0026gt;result\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;o\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;mf\u0026#34;\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;p\u0026#34;\u0026gt;;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;k\u0026#34;\u0026gt;while\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;p\u0026#34;\u0026gt;(\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;n\u0026#34;\u0026gt;i\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;o\u0026#34;\u0026gt;\u0026amp;lt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;n\u0026#34;\u0026gt;e\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;p\u0026#34;\u0026gt;)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;p\u0026#34;\u0026gt;{\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;n\u0026#34;\u0026gt;result\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;o\u0026#34;\u0026gt;*=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;n\u0026#34;\u0026gt;base\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;p\u0026#34;\u0026gt;;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;n\u0026#34;\u0026gt;i\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;o\u0026#34;\u0026gt;+=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;mf\u0026#34;\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;p\u0026#34;\u0026gt;;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;p\u0026#34;\u0026gt;}\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;k\u0026#34;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;n\u0026#34;\u0026gt;result\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;p\u0026#34;\u0026gt;;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;p\u0026#34;\u0026gt;}\u0026lt;/span\u0026gt; \u0026lt;/pre\u0026gt;\u0026lt;/div\u0026gt;   效果 func power(base: int, e: int) -\u0026gt; int { var i = 0; var result = 1; while(i \u0026lt; e) { result *= base; i += 1; } return result; }   "});index.add({'id':5,'href':'/posts/hugo-tutorial/','title':"Getting Started with Hugo",'content':""});index.add({'id':6,'href':'/posts/','title':"Posts",'content':""});index.add({'id':7,'href':'/docs/contributing/','title':"Contributing",'content':"撰写中\u0026hellip;\n"});index.add({'id':8,'href':'/docs/doc/','title':"Doc",'content':"撰写中\u0026hellip;\n"});index.add({'id':9,'href':'/docs/experiment/ycc/','title':"Ycc",'content':"YCC实验框架 撰写中\n"});index.add({'id':10,'href':'/docs/inprogress/','title':"Inprogress",'content':"撰写中 "});index.add({'id':11,'href':'/docs/source/','title':"Source",'content':"源代码 “言”项目的代码被分为许多子项目，所有代码都托管在 Github 上。\n编译器框架   Yan Foundation : 面向老师和学生的编译器框架。  Yan Language : 为阐述Yan Foundation设计的一款微型语言。  Token util : 面向老师的词法单词类型代码生成工具。  自动评测系统   OJ Website : 自动评测系统的网站前后端。 OJ Core: 自动评测系统的内核。  实验框架   YCC : 基于Yan foundation的C语言编译器实现框架。  "});index.add({'id':12,'href':'/posts/compiler-framework/','title':"Compiler Framework",'content':"Design note 如何给语言添加IO功能\n  Adding a function call in my IR code in llvm   llvm - How to implement print function in my language?   How To Call @printf in LLVM through the module builder system   private char skipWhitespace(char ch) { while (true) { if (ch == \u0026#39; \u0026#39; || ch == \u0026#39;\\t\u0026#39; || ch == \u0026#39;\\n\u0026#39;) ch = buffer.next(); else break; } return ch; } 改写buffer.peek()\npublic boolean peek(char ch) { if(peek() == ch) { next(); return true; } return false; } // To public boolean peek(char... chs) { char cur_ch = peek(); for(char ch : chs) { if (cur_ch == ch) { next(); return true; } } return false; } private void skipWhitespace() { while (buffer.peek(\u0026#39; \u0026#39;, \u0026#39;\\t\u0026#39;, \u0026#39;\\n\u0026#39;, \u0026#39;\\r\u0026#39;)) buffer.next(); } "});index.add({'id':13,'href':'/posts/online-judge/','title':"Online Judge",'content':""});index.add({'id':14,'href':'/docs/','title':"Docs",'content':""});index.add({'id':15,'href':'/docs/download/','title':"下载安装",'content':"下载安装 Yan Foundation是一个以jar包形式发布的Java framework。你可以直接下载jar包导入你的java项目中，也可以使用你熟悉的构建工具，例如Maven和Gradle。\n下载Jar包\n你可以在以下地方下载到预编译的jar包，当前最新版为0.2-beta。\n  Github Release   Maven Central   使用构建工具\nMaven 在你的Maven项目中的pom.xml添加以下内容:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.yan-lang\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;yan-foundation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Gradle 暂无教程 项目模版 如果你只是想要快速体验这个框架，看看它能做些什么，你也可以选择直接下载下面的这些模版。\n 使用Idea的Java项目, 请下载 yan-foundation-idea-java 项目。 使用Idea的Maven项目，请下载 yan-foundation-idea-maven 项目。  "});index.add({'id':16,'href':'/docs/about/','title':"关于言",'content':"关于\u0026quot;言\u0026rdquo; 言(Yan)是一款面向编译原理教学的实践平台。该项目致力于改善\u0026quot;初次接触编译原理课程的同学\u0026quot;编写第一个编译器\u0026amp;解释器时的编程体验，并为学生与老师提供一个功能较为完善的自动评测系统。\n该项目包含数个子项目:\n   Yan Foundation (Working in Progress)是一个编写编译器\u0026amp;解释器的框架，它封装了许多编写任意语言编译器时都需要的一些实用模块，如命令行参数处理，文本IO，交互式命令行(REPL)，格式化输出工具和出错处理等。通过该框架，学生能够在学习完理论知识后，结合框架编写少量代码，即可迅速完成一个“比较那么回事”的一个编译器ˉ\n   Yan Language (Working in Progress)是为了阐述Foundation用法设计的一个微型编程语言，我们利用Foundation框架为Yan语言编写了一个简易的编译器和解释器。\n   Token util 是一个协助老师为词法分析器生成统一的Token类型的工具。\n  该项目目前正在开发之中，目前已经基本完成词法以及语法分析器框架部分的开发，欢迎下载我们的Beta版本进行体验。\n"});index.add({'id':17,'href':'/docs/quick-start/','title':"快速开始",'content':"快速开始 假设我们有一个语言Simple，这个语言只能定义变量，定义变量的规则是先写一个var关键字，然后空格接一个标识符，标识符只能有字母和数字组成，然后可以有一个初始值number，初始值必须是个整数。无需声明类型。\n\u0026#39;var\u0026#39; ID \u0026#39;=\u0026#39; number 现在我们利用Foundation框架，为这个语言编写一个简单的词法分析器和语法分析器。 Let\u0026rsquo;s Start!\n新建一个项目 下面详细阐述如何将框架导入你的Java项目之中，如果你之前有过使用Java第三方库的经历，你可以选择跳过这一章节，从 下载安装 页面直接下载jar包自行导入。\n \u0008Yan-Foundation Jar导入教程 展开  推荐使用Intellij Idea作为开发环境，当然你也可以使用Eclipse，本文以Idea为例。\n 打开Idea，新建一个Java项目，选择Java SDK。  Foundation框架使用Java11构建，因此你需要使用Java11或更高版本。当前Oracle发布的最新版本是Java13，如果你的版本低于11，你可以前往Oracle官网下载最新版本的Java SDK。  一直点Next直到创建好项目，你将会得到类似下图的项目结构。如果你勾选了Create Project from Template，你将会和我一样获得一个Main文件。如果没有，你可以自己创建一个。\n导入Foundation依赖   对Java不熟悉的同学，可以把这一步想成C++/C的include，或者是Python的pip install。\n 在这里，我们使用jar包(点击下载)的形式导入foundation框架。依照下图步骤操作，在第四步后会弹出一个文件选择界面，选择刚刚下载的jar包，然后一直点击OK即可。\n   最开始的开始 创建一个可以执行的解释器还有命令行程序需要多少行代码？100？1000？  使用foundation框架，你只需要在你的main函数中添加如下两行代码即可。\npackage yan.demo.simple; import yan.foundation.Language; import yan.foundation.Launcher; public class Main { public static void main(String[] args) { Language language = new Language(); Launcher.launch(language, args); } } 解释器 如果你使用Idea，点击main函数旁边的绿色三角形即可启动程序。启动之后，你将看到类似下图所示的一个交互式解释器。\n 你可以在这里输入代码，或者一些内建指令。内建指令以冒号:开头，对于其他不以冒号开头的字符串，解释器将其视为代码，当你按下回车时，解释器为调用你编写的Phase(如词法分析器)等对代码进行分析，并把结果显示出来（图中展示的例子没有显示任何东西，因为你还没有为你的语言编写Phase！）。\n 最常用的内建指令是:help，你可以通过这个指令获取解释器支持哪些内建指令。 怎么添加Phase(词法分析器/语法分析器)？后面会讲。   命令行程序 事实上，在获得一个交互式解释器的同时，你还获得了一个Simple语言的命令行程序，你可以像下面这样在命令行中指定输入文件，输出文件，其他参数等，就像使用Python或者GCC一样。\n// 你需要将程序打包成simple.jar java -jar simple.jar input.simple -o out.txt 如果你输入java -jar simple.jar --help，你还会看到如下的帮助信息。\nUsage: \u0026lt;main class\u0026gt; [-hV] [-o=\u0026lt;outputFile\u0026gt;] [-t=\u0026lt;target\u0026gt;] \u0026lt;inputFile\u0026gt; \u0026lt;inputFile\u0026gt; The file to be processed. -h, --help Show this help message and exit. -o, --output=\u0026lt;outputFile\u0026gt; Output file for result -t, --target=\u0026lt;target\u0026gt; The stage you want to compile to. Valid values: . Default: null -V, --version Print version information and exit. 细心的同学可能会注意到, 这里有一个参数target, 这个参数实际上指定的是你编写的编译器要编译到哪个阶段。因为你还没有为编译器编写任何一个阶段，所以现在它的Valid values和default都是空或者null。\n当你编写好词法分析器和语法分析器时，valid value就会变成类似lex, parse之类的，到时候你就可以使用命令行参数进行指定，获取中间结果。\n类似的，使用我们的框架，这些功能都是免费送的，你几乎不需要编写任何代码。\n 一些概念 在正式开始编写词法分析器之前，我们先了解一个概念Phase。\nPhase\n相信在编译原理的前几节课，老师们都会跟你们讲编译器的组成，通常来说，编译器由5或6个阶段构成，例如词法分析器，语法分析器，语义分析器，中间代码生成，代码优化和目标代码生成。\n事实上，当我们把这些过程抽象出来，我们会发现，每个过程其实就是将程序的一种表示转换成另一种。在我们的foundation框架中，这个过程被定义为一个Phase。例如，词法分析器Phase\u0026lt;String, List\u0026lt;Token\u0026gt;\u0026gt;就是从string到一个token列表，语法分析器Phase\u0026lt;List\u0026lt;Token\u0026gt;, Tree.TopLevel\u0026gt;就是从Token列表转换成一棵抽象语法树。\n在我们的框架中，创建Phase和添加Phase都十分简单，请接着往下看。\n词法分析器 现在我们来为了我们的Simple语言编写一个词法分析器（Lexer Phase）。\n 首先新建一个文件Lexer.java，修改里面的内容成如下所示。    AbstractLexer 是foundation框架中提供的一个Lexer模版，该类继承自Phase\u0026lt;String, List\u0026lt;Token\u0026gt;\u0026gt;，\u0008并\u0008提供许多你在词法分析中\u0008可以使用的实用函数（Helper Function）。对于该类你只需要实现nextToken函数。\n   Token 是foundation框架中定义的单词(Token)的数据结构。\n    import yan.foundation.compiler.frontend.lex.AbstractLexer; import yan.foundation.compiler.frontend.lex.Token; public class Lexer extends AbstractLexer { @Override public Token nextToken() { return null; } }  在Main.java中添加我们刚刚编写的词法分析器。\n 向你的语言中添加一个词法分析器特别简单，只需要调用语言对象.addPhase()即可。 addPhase()包含两个参数：  第一个参数接受一个Phase\u0026lt;In, Out\u0026gt;即一个编译阶段。（这就是为什么AbstractLexer需要继承自Phase\u0026lt;String, List\u0026lt;Token\u0026gt;\u0026gt;。 第二个参数是一个字符串target，这个字符串会作为命令行选项--target的可选值。      public static void main(String[] args) throws Exception { // addPhase可能会抛出异常  Language language = new Language(); language.addPhase(new Lexer(), \u0026#34;lex\u0026#34;); // 新增  Launcher.launch(language, args); } 虽然我们还没有真正的编写分析逻辑，不过没关系，现在你可以点击三角箭头，运行看看吧。\n语法分析器 test\n"});})();